# ООП
* Статическое поле/метод
* Инкапсуляция; модификаторы доступа: public, private, protected; свойство класса (геттер, сеттер)
* Наследование, Абстрактный класс
* Ассоциация, Агрегация, Композиция, разница между ними
* Плюсы и минусы наследования. В каких случаях стоит применять композицию, а в каких наследование, при проектировании. (привести пример сравнения)  
* Основное назначение интерфейсов. Полиморфизм подтипов  
* Множественное наследование, проблема ромбовидного наследования. Наследование через интерфейсы делегирование
* Связность, связанность. Как повысить связность, как понизить связанность? Декомпозиция
* UML диаграмма классов   
* Шаблоны (понимание, обоснование применения): Издатель-подписчик (Publish–subscribe), Одиночка,Фабричный метод, Абстрактная фабрика  
* MVC - Отношения между моделью, вьюхой и контроллером 
* СОЛИД, первые четыре принципа (поверхностное представление)


## Статическое поле/метод.
При создании объектов класса для каждого объекта создается своя копия не статических обычных полей.  
Статические поля являются общими для всего класса. Поэому они могут использоваться без создания объектов класса.  

## Инкапсуляция; модификаторы доступа: public, private, protected; свойство класса (геттер, сеттер).
Инкапсуляция это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя. Инкапсуляция неразрывно связана с понятием интерфейса класса. По сути, всё то, что не входит в интерфейс, инкапсуляция в классе.

### Модификаторы доступа:
* public — общедоступные
* protected —доступуные только для потомко
* private — доступные только внутри класса
* геттер - TODO
* сеттер - TODO

## Наследование, Абстрактный класс.  
### Наследование
Cвойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.
### Абстрактный класс - это класс у которого не может быть объектов который должен содержать хотя бы один метод, который задекларирован  но не реализован, реализация метода ложиться на дочерние классы.  

## Ассоциация, Агрегация, Композиция, разница между ними.

### Ассоциация это такой тип при котором объекты будут ссылаться друг на друга. При этом они остаются полностью независимыми друг от друга.
Ассоциация это когда у одного класса есть ссылка на другой класс.
```
class Logger {
  constructor() {
    this.stream = null;
  }
  log(message) {
    if (this.stream) {
      this.stream.write(message);
    }
  }
}
const logger = new Logger();
logger.stream = process.stdout;
logger.log('Here we are');
```

### Агрегация это тип отношений когда один объект является частью другого. Агрегация образует слабую связь между объектами. Все зависимые классы инициализируются вне основного объекта.
‘’’
class Logger {
  constructor(stream) {
    this.stream = stream;
  }
  log(message) {
    if (this.stream) {
      this.stream.write(message);
    }
  }
}
const logger = new 
logger(process.stdout);
logger.log('Here we are’);
‘’’

### Композиция 
 При таком типе отношений основной объект полностью обеспечивает жизненный цикл объектов от которых он зависит. (Класс вызывающий внешний класс из библиотеки)
‘’’
const fs = require('fs')
class Logger {
  constructor(name) {
    this.stream = fs.createWriteStream(name);
  }
  log(message) {
    this.stream.write(message);
  }
}
const logger = new Logger('file.log');
logger.log('Here we are');
‘’’

## Плюсы и минусы наследования. В каких случаях стоит применять композицию, а в каких наследование, при проектировании. (привести пример сравнения)
### Плюсы наследования:  
+ используется статически на этапе компиляции.  

### Минусы наследования
⁃ нарушает инкапсуляцию.  
⁃ Тесная связь влекущая за собой изменение в подклассе.  
⁃ Зависимость от реализации может повлечь за собой проблемы при попытке повторного использования подкласса. Если хотя бы один аспект унаследованной реализации непригоден для новой предметной области, то приходится переписывать родительский класс или заменять его чем-то более подходящим.  

### Композиция
- TODO

## Основное назначение интерфейсов. Полиморфизм подтипов.  

### Интерфейс - уровень абстракции который говорит что данный класс будет делать, а абстракцией ниже уже находятся методы которые определяют как. (Логика выполнения может меняться)  
Автор языка С++ Бьен Страуструп охарактеризовал полиморфизм подтипов как “один интерфейс — много реализаций”.

### Полиморфизм – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта нее стоит путать с параметрическим полиморфизмом.  
Параметрический полиморфизм - подразумевает исполнение одного и того же кода для всех допустимых типов аргументов.  

## Множественное наследование, проблема ромбовидного наследования. Наследование через интерфейсы, делегирование.  
### Проблемы
Проблемы как такого множественного наследование это дублирование переменных.
Проблемы ромбовидного наследования, это замыкание в следствии которого потеря памяти из за дублирование переменных в дочерних классах.  

### Наследование через интерфейсы
У интерфейсов нет данных как у абстрактных классов и каждая функция которая есть у интерфейса должна быть виртуальной.

### Делегирование
- TODO

## Связность, связанность. Как повысить связность, как понизить связанность? Декомпозиция.
### Cвязывание - это когда часть кода (модуль) знает структуру данных, методы, события, контракты другой части модуля.
Способы связывания:
1. через обращение к данны (Наиболее связанный код, получается неразрывный модуль)
2. Вызовов функций или методов (Менее связанный, разные модули)
3. трансляция событий

### Под связностью (связка) подразумевают насколько тот или иной модуль является узкопрофильным. Связность должна быть высокой.
Если в слое бизнес-процесса расположить инициализацию строки соединения, выборку данных , то это приведет к сильной связанности (увязки) программного кода и слабой связности внутри модуля.  
Для обратного поведения нужно разделять логику на разные уровни.  
Использовать dependency ingection.   
(Вместо того, чтобы создавать Service объект внутри App класса, надо создать Service заранее и затем передать его в объект App как аргумент конструктора.)
[Подробнее](https://tyapk.ru/blog/post/dependency-injection-and-service-container)

## UML диаграмма классов.
Структурная диаграмма языка моделирования UML, демонстрирующая общую структуру иерархии классов системы, их коопераций, атрибутов (полей), методов, интерфейсов и взаимосвязей между ними.

## Шаблоны (понимание, обоснование применения) Издатель-подписчик (Publish–subscribe), Одиночка, Фабричный метод, Абстрактная фабрика.
### Шаблон проектирования, или паттерн.  
В разработке программного обеспечения — повторяемая архитектурная конструкция, представляющая собой решение проблемы проектирования, в рамках некоторого часто возникающего контекста.

### Одиночка
Обеспечивает тот факт, что создаваемый объект является единственным объектом своего класса.  
Вообще шаблон одиночка признан антипаттерном, необходимо избегать его чрезмерного использования. Он необязательно плох и может иметь полезные применения, но использовать его надо с осторожностью, потому что он вводит глобальное состояние в ваше приложение.  

### Фабричный метод
Порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс создавать. Иными словами, данный шаблон делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.

### Абстрактная фабрика
Порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие этот интерфейс.  

### Издатель-подписчик (англ. PubSub)
Поведенческий шаблон проектирования передачи сообщений, в котором отправители сообщений, именуемые издателями (англ. publishers), напрямую не привязаны программным кодом отправки сообщений к подписчикам(англ. subscribers). Вместо этого сообщения делятся на классы и не содержат сведений о своих подписчиках, если таковые есть. Аналогичным образом подписчики имеют дело с одним или несколькими классами сообщений, абстрагируясь от конкретных издателей..

## MVC - Отношения между моделью, вьюхой и контроллером.
### MVC
Подход к проектированию приложения, который предполагает выделение кода в блоки модель, представление и контроллер.   
* Контроллер обрабатывает входящие запросы.  
* Модель достаёт из базы данных информацию, нужную для выполнения конкретных запросов.  
* Представление определяет результат запроса, который получает пользователь.  

## СОЛИД, первые четыре принципа (поверхностное представление).
### S: Single Responsibility
Principle (Принцип единственной ответственности). 
Класс должен быть ответственным только за что то одно.  

### O: Open-Closed Principle
(Принцип открытости-закрытости).  

### L: Liskov Substitution Principle
(Принцип подстановки Барбары Лисков).  

### I: Interface Segregation Principle  
(Принцип разделения интерфейса).  

### D: Dependency Inversion Principle
(Принцип инверсии зависимостей).  
