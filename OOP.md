# ООП
* Статическое поле/метод
* Инкапсуляция; модификаторы доступа: public, private, protected; свойство класса (геттер, сеттер)
* Наследование, Абстрактный класс
* Ассоциация, Агрегация, Композиция, разница между ними
* Плюсы и минусы наследования. В каких случаях стоит применять композицию, а в каких наследование, при проектировании. (привести пример сравнения)  
* Основное назначение интерфейсов. Полиморфизм подтипов  
* Множественное наследование, проблема ромбовидного наследования. Наследование через интерфейсы делегирование
* Связность, связанность. Как повысить связность, как понизить связанность? Декомпозиция
* UML диаграмма классов   

***

## Статическое поле/метод.
Метод, свойство не привязанное к конкретному экземпляру. Записывается в функцию конструктор.  
Используется для служебных функций, логирования, фабричных методов.  
Статические поля, методы наследуются.

***

## Инкапсуляция; модификаторы доступа: public, private, protected; свойство класса (геттер, сеттер).
Инкапсуляция это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя. Инкапсуляция неразрывно связана с понятием интерфейса класса. По сути, всё то, что не входит в интерфейс, инкапсуляция в классе.

#### Модификаторы доступа:
* public — общедоступные
* protected —доступуные только для потомко
* private — доступные только внутри класса
* Get/set - это свойства-аксессоры (accessor properties). По своей сути это функции, которые используются для присвоения и получения значения, но во внешнем коде они выглядят как обычные свойства объекта. Они позволяют в любой момент взять «обычное» свойство и изменить его поведение, поменяв на геттер и сеттер.
```javascript
const obj = {
	_name: '',

	get name() {
  	return this._name;
  },
  set name(value) {
  	this._name = value;
  }
}

obj.name = 'Bobby';
console.log(obj.name) // Bobby
```
[подробнее о get/set](https://learn.javascript.ru/property-accessors)  

***

## Наследование, Абстрактный класс.  
#### Наследование
Cвойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.
#### Абстрактный класс
Базовый класс, не предпологающий создание экземпляров. Обычно содержит абстрактные методы, наследуемые потомками ( реализация полиморфизма ).  

***

## Ассоциация, Агрегация, Композиция, разница между ними.

#### Ассоциация 
Ассоциация это такой тип при котором объекты будут ссылаться друг на друга. При этом они остаются полностью независимыми друг от друга.
(Ассоциация это когда у одного класса есть ссылка на другой класс)

```javascript
class Logger {
  constructor() {
    this.stream = null;
  }
  log(message) {
    if (this.stream) {
      this.stream.write(message);
    }
  }
}
const logger = new Logger();
logger.stream = process.stdout;
logger.log('Here we are');
```

#### Агрегация 
Агрегация это тип отношений когда один объект является частью другого. Агрегация образует слабую связь между объектами. Все зависимые классы инициализируются вне основного объекта.  
```javascript
class Logger {
  constructor(stream) {
    this.stream = stream;
  }
  log(message) {
    if (this.stream) {
      this.stream.write(message);
    }
  }
}
const logger = new 
logger(process.stdout);
logger.log('Here we are’);

```

#### Композиция 
 При таком типе отношений основной объект полностью обеспечивает жизненный цикл объектов от которых он зависит. (Класс вызывающий внешний класс из библиотеки)
```javascript
const fs = require('fs')
class Logger {
  constructor(name) {
    this.stream = fs.createWriteStream(name);
  }
  log(message) {
    this.stream.write(message);
  }
}
const logger = new Logger('file.log');
logger.log('Here we are');
```

***

## Плюсы и минусы наследования. В каких случаях стоит применять композицию, а в каких наследование, при проектировании. (привести пример сравнения)
#### Плюсы наследования:  
+ используется статически на этапе компиляции.  
+ выстраивает понятную архитектуру

#### Минусы наследования
⁃ нарушает инкапсуляцию.  
⁃ Тесная связь влекущая за собой изменение в подклассе.  
⁃ Зависимость от реализации может повлечь за собой проблемы при попытке повторного использования подкласса. Если хотя бы один аспект унаследованной реализации непригоден для новой предметной области, то приходится переписывать родительский класс или заменять его чем-то более подходящим.  

***

## Основное назначение интерфейсов. Полиморфизм подтипов.  

#### Интерфейс
**Интерфейс** - это граница между объектами системы, через которую они взаимодействуют.  
Определяет основные средства и границы коммуникации между классами или компонентами.
Также можно представить как спецификацию или контракт который должен реализовать класс. В typescript интерфейс описывает поля и методы классов ( например в React это могут быть интерфесы для props и state ).

#### Полиморфизм
Полиморфизм – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта нее стоит путать с параметрическим полиморфизмом.  
Параметрический полиморфизм - подразумевает исполнение одного и того же кода для всех допустимых типов аргументов.  

***

## Множественное наследование, проблема ромбовидного наследования. Наследование через интерфейсы, делегирование.  
#### Проблемы
Проблемы как такого множественного наследование это дублирование переменных.
Проблемы ромбовидного наследования, это замыкание в следствии которого потеря памяти из за дублирование переменных в дочерних классах.  

#### Наследование через интерфейсы
У интерфейсов нет данных как у абстрактных классов и каждая функция которая есть у интерфейса должна быть виртуальной.

#### Делегирование
- TODO

***

## Связность, связанность. Как повысить связность, как понизить связанность? Декомпозиция.
#### Cвязывание - это когда часть кода (модуль) знает структуру данных, методы, события, контракты другой части модуля.
Способы связывания:
1. через обращение к данны (Наиболее связанный код, получается неразрывный модуль)
2. Вызовов функций или методов (Менее связанный, разные модули)
3. трансляция событий

#### Под связностью (связка) подразумевают насколько тот или иной модуль является узкопрофильным. Связность должна быть высокой.
Если в слое бизнес-процесса расположить инициализацию строки соединения, выборку данных , то это приведет к сильной связанности (увязки) программного кода и слабой связности внутри модуля.  
Для обратного поведения нужно разделять логику на разные уровни. (использовать dependency ingection)  
(Вместо того, чтобы создавать Service объект внутри App класса, надо создать Service заранее и затем передать его в объект App как аргумент конструктора.)
[Подробнее](https://tyapk.ru/blog/post/dependency-injection-and-service-container)

***

## UML диаграмма классов.
Структурная диаграмма языка моделирования UML, демонстрирующая общую структуру иерархии классов системы, их коопераций, атрибутов (полей), методов, интерфейсов и взаимосвязей между ними.
