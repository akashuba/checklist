## ComputerScience
* [Структуры данных](https://github.com/sagalatov/checklist/blob/master/ComputerScience.md#%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)
* [Сложность алгоритмов](https://github.com/sagalatov/checklist/blob/master/ComputerScience.md#%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2-on)

### Структуры данных.  
1. **Arrays** - массив, простой способ хранения набора элементов в памяти компьютера. Выделяется пространство в памяти для последовательной записи элементов. Все элементы занимают равные объемы памяти. Каждому из них присваивается неотрицательное числовое значение – индекс, который соответствует позиции этого элемента в массиве.
2. **Linked list** - связный список. Позволяет хранить элементы в цепи ячеек, которые не обыязательно должны находиться в последовательных адресах памяти. Каждая ячейка имеет указатель, сообщающий об адресе следующей в цепи.
3. **Stack** - стек это базовая структура данных, которая позволяет добавлять или удалять элементы только в её начале.
Стек организован по принципу LIFO (Last In First Out, «последним пришёл — первым вышел»).  
4. **Queue** - Очередь устроена по принципу FIFO (First In First Out, «первый пришёл — первый вышел»). Это значит, что удалить элемент можно только после того, как были убраны все ранее добавленные элементы.
5. **Map** - это структура, которая хранит данные в парах ключ/значение, где каждый ключ уникален. Иногда её также называют ассоциативным массивом или словарём. Map часто используют для быстрого поиска данных.
6. **Hash Table** - это похожая на Map структура, которая содержит пары ключ/значение. Она использует хэш-функцию для вычисления индекса в массиве из блоков данных, чтобы найти желаемое значение.
7. **Binary tree** - ячейки в дереве имеют указатели на другие ячейки, однако, в отличае от связных списков, они распологаются не линейно. Диревья удобны для иерархических структур, таких как каталоги файлов. Все узлы имеют одного радителя. Двоичные деревья поиска позволяют быстро находить, добавлять и удалять элементы. Они устроены так, что время каждой операции пропорционально логарифму общего числа элементов в дереве.  
8. **Graph** - аналогичен дереву, с разницей в том, что у него не ни дочерних ни родительских узлов, так что любой узел может иметь произвольное количетво входящих и исходящих ребер.  

[Более подробно о структурах данных](https://netology.ru/blog/10-data-structures)
  
### Сложность алгоритмов O(n). 
**O(n)** - функция позволяющая выразить рост временных затрат на выполнение вычислений (алгоритмов). Где n - количество элементов входных данных.
![Big_O](/img/big_O_chart.png)  
Например:  
1. Выборка из объекта (хэш таблицы): Θ(1)
2. Поиск по массиву: Θ(n)
3. Поиск по бинарному дереву Θ(log(n))  
4. Quiksort Θ(n log(n))
5. Bubble Sort Θ(n^2) 
6. Бинарный поиск в отсортированном массиве - O(logn).  

[Таблица сложностей алгоритмов](https://www.bigocheatsheet.com/)
