# Чек лист фронтенд разработчика 


# Web

1. сессии
Это некоторый отрезок во времени, в пределах которого веб-приложение может определять все запросы от одного клиента. (Когда клиент в первые передает свои данные в запросе, на сервере создается новая сессия для этого клиента и в пределах  и в период времени жизни сессии  все запросы от этого клиента будут однозначно идентифицированы только с ним, по истечению времени запрос связь будет потеряна и новый запрос будет обрабатываться как совершенно новый и не связанный с клиентом)

2. cors
CORS — это механизм безопасности, который позволяет веб-странице из одного домена обращаться к ресурсу с другим доменом (кросс-доменным запросом). Без таких функций, как CORS, веб-сайты ограничиваются доступом к ресурсам одного и того же происхождения через так называемую политику единого происхождения.
Спецификация CORS определяет набор заголовков, которые позволяют серверу и браузеру определять, какие запросы для междоменных ресурсов (изображения, таблицы стилей, сценарии, данные и т. д.) разрешены, а какие нет. CORS является техникой для ослабления правила одного источника, позволяя JavaScript на web странице обрабатывать REST API запросы от другого источника.

3. csrf    
CSRF-атака – это когда «злая страница» отправляет форму или запрос на сайт, где посетитель, предположительно, залогинен.
Если сайт проверяет только куки, то он такую форму принимает. А делать это не следует, так как её сгенерировал злой хакер.
Для защиты от атаки формы, которые генерирует mail.com, подписываются специальным токеном. Можно не все формы, а только те, которые осуществляют действия от имени посетителя, то есть могут служить объектом атаки.

4. headers (cache, useragent, location )
    
headers : HTTP заголовки сопровождают обмен данными по протоколу HTTP. Они могут содержать описание данных и информацию необходимую для взаимодействия между клиентом и сервером. Заголовки и их статусы перечислены в реестре IANA, который постоянно обновляется.
cashe:  Кеширование - этот метод, заключающийся в сохранении копии полученного ресурса, чтобы вернуть ее по запросу. Запрос на ресурс, уже имеющийся в веб-кеше, перехватывается, и вместо обращения к исходному серверу выполняется загрузка копии из кеша. Таким образом снижается нагрузка на сервер, которому не приходится самому обслуживать всех клиентов, и повышается производительность - кеш ближе к клиенту, и ресурс передается быстрее. Кеширование является  основным источником повышения производительности веб-сайтов. Однако, кеш надо правильно сконфигурировать: ресурсы редко остаются неизменными, так что копию требуется хранить только до того момента, как ресурс изменился, но не дольше.
Существует несколько видов кешей, которые можно разделить на две основные категории: приватные кеши и кеши совместного использования. В кешах совместного использования (shared cache) хранятся копии, которые могут направляться разным пользователями. Приватный кеш (private cache) предназначен для отдельного пользователя
useragent: User-Agent — это текстовая часть запроса, которую веб-приложения используют для сообщения сайту информации о себе. User-Agent браузера содержит название и версию приложения, а также данные об операционной системе компьютера: версия, разрядность, язык по умолчанию и другие параметры. 
locationc: HTTP-заголовок Location возвращается в ответах HTTP-сервера в двух случаях:
Чтобы попросить браузер загрузить другую web-страницу (Перенаправление URL). В этом случае заголовок Location должен быть отправлен вместе с кодом состояния3xx
Для предоставления информации о новом местоположении ресурса. Код состояния должен быть 201 или 202

5. cookie
HTTP cookie (web cookie, cookie браузера) - это небольшой фрагмент данных, отправляемый сервером на браузер пользователя, который тот может сохранить и отсылать обратно с новым запросом к данному серверу. Это, в частности, позволяет узнать, с одного ли браузера пришли оба запроса (например, для аутентификации пользователя). Они запоминают информацию о состоянии для протокола HTTP, который сам по себе этого делать не умеет.
Cookie используются, главным образом, для:
⦁ Управления сеансом (логины, корзины для виртуальных покупок)
⦁ Персонализации (пользовательские предпочтения)
⦁ Мониторинга (отслеживания поведения пользователя)
До недавнего времени cookie принято было использовать в качестве хранилища информации на стороне пользователя. Это могло иметь смысл в отсутствии вариантов, но теперь, когда в распоряжении браузеров появились различные API (программные интерфейсы приложения) для хранения данных, это уже не так. Из-за того, что cookie пересылаются с каждым запросом, они могут слишком сильно снижать производительность (особенно в мобильных устройствах). В качестве хранилищ данных на стороне пользователя вместо них можно использовать Web storage API (localStorage and sessionStorage) и IndexedDB.

6. get, post, option; body, query; http status
        
get 
Метод GET запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.

post
В программировании POST — один из многих методов запроса, поддерживаемых HTTP протоколом, используемым во Всемирной паутине. Метод запроса POST предназначен для запроса, при котором веб-сервер принимает данные, заключённые в тело сообщения, для хранения. Он часто используется для загрузки файла или представления заполненной веб-формы.

option
HTTP-метод OPTIONS используется для описания параметров соединения с целевым ресурсом. Клиент может указать особый URL для обработки метода OPTIONS, или * (зведочку) чтобы указать весь сервер целиком.

body
Последней частью запроса является его тело. Оно бывает не у всех запросов: запросы, собирающие (fetching) ресурсы, такие как GET, HEAD, DELETE, или OPTIONS, в нем обычно не нуждаются. Но некоторые запросы отправляют на сервер данные для обновления, как это часто бывает с запросами POST (содержащими данные HTML-форм).
Тела можно грубо разделить на две категории: 
Одноресурсные тела (Single-resource bodies), состоящие из одного отдельного файла, определяемого двумя заголовками: Content-Type и Content-Length.
Многоресурсные тела (Multiple-resource bodies), состоящие из множества частей, каждая из которых содержит свой бит информации. Они обычно связаны с HTML-формами .
Последней частью ответа является его тело. Оно есть не у всех ответов: у ответов с кодом состояния, например, 201 или 204, оно обычно отсутствует.
Тела можно разделить на три категории:
Одноресурсные тела (Single-resource bodies), состоящие из отдельного файла известной длины, определяемые двумя заголовками: Content-Type и Content-Length.
Одноресурсные тела (Single-resource bodies), состоящие из отдельного файла неизвестной длины, разбитого на небольшие части (chunks) с заголовком Transfer-Encoding, значением которого  является chunked.
Многоресурсные тела (Multiple-resource bodies), состоящие из многокомпонентного тела, каждая часть которого содержит свой сегмент информации. Они относительно редки.

query
Строка запроса - часть унифицированного указателя ресурса 
Пример: http://example.com/over/there?name=ferret&сOlof=purpule
 ? - разделитель 
& - разделитель множественных запросов
Ссылка по теме: ru.qwe.wiki/wiki/query_string

http
HTTP (англ. HyperText Transfer Protocol — «протокол передачи гипертекста») — протокол прикладного уровня передачи данных изначально — в виде гипертекстовых документов в формате «HTML», в настоящий момент используется для передачи произвольных данных. Основой HTTP является технология «клиент-сервер», то есть предполагается существование:
* Потребителей (клиентов), которые инициируют соединение и посылают запрос;
* Поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.

status 
Код состояния HTTP (англ. HTTP status code) — часть первой строки ответа сервера при запросах по протоколу HTTP. Он представляет собой целое число из трёх десятичных цифр. Первая цифра указывает на класс состояния. За кодом ответаобычно следует отделённая пробелом поясняющая фраза на английском языке, которая разъясняет человеку причину именно такого ответа
https://yandex.ru/support/webmaster/error-dictionary/http-codes.html

7. REST - принципы наименование методов, принцип stateless
REST (Representational state transfer) – это стиль архитектуры программного обеспечения для распределенных систем, таких как World Wide Web, который, как правило, используется для построения веб-служб. Термин REST был введен в 2000 году Роем Филдингом, одним из авторов HTTP-протокола. Системы, поддерживающие REST, называются RESTful-системами.
Принципы наименования: www.restapitutorial.ru/lessons/restfulresourcenaming.html
Принцип stateless
Ссылка: 
Состояние хранится на клиенте 

8. Используемые коды ошибок
???


## Командный код

Именование
1. Имена должны передавать намерения программиста: 
Имя не должно требовать дополнительных комментариев;
 -должна отвечать на главные вопросы, почему эта переменная существует и что она делает.
 -должно быть содержательным

2.  Избегать дезинформации
 Ложные ассоциации 
 Избегать скрытые значения отличные от предполагаемого 
 -hp это и разновидность Unix и длина гипотенузы.
 -Длинные похожие имена можно спутать, как пример автодополнение 
 -Не стоит писать acountList если данные не в List
 -Строчная l и 1 0 и o (избегать) 

3.  Осмысленные различия 
 -a1, a2 - не несут информации.
 -Есть класс: Product -> ProductInfo и ProductData 
 Info Data не несут полезной информации.

4. Удобопроизносимые имена
Программирование это социальная деятельность и не хочется выглядишь идиотом. GenerationTimestamp вместо genymdhms 

5. Выбирать имена удобные для поиска 
«e» самая распространённая буква английского алфавита подобное именование может быть использовано только только в локальных переменных в коротких методах. Длинна имени должна соответствовать размеру области видимости 

6. Избегать схем кодирования имён
 Плохо произносится, легко сделать опечатку, дополнительная нагрузка для изучения 

7. Избегать мысленных преобразований 
 Не создавать временных заменителей который должен мысленно преобразован 
 (Нет хуже концепции выбрать с если а уже занято) 

8. Имена классов и методов 
 Имена классов и объектов должны быть существительными и их комбинациями Customer, Account, AddressParser. Не использовать: info data processor manager, имя класса не должно быть глаголом.
 Имя методов: глаголы и глагольные сочетания. postPayment, deletePage, save
 Методы чтения / записи get set и is

9. Избегать остроумия
 У всех разное чувство юмора, возможна неправильная трактовка переменных. 

10. Выбирать одно слово для каждой концепции 
 Не должно существовать в разных классах эквивалентных методов (путаница)
11. Использовать имена из пространства решения
Не стесняться использовать термины из области информатики, паттернов, тех.понятий понятных разработчикам AccountVisitor

12. Использовать имена из пространства задачи 
 Если нет подходящих названий из пространства решений, использовать имена из пространства задачи. Уточнить у специалиста предметной области 

13. Добавлять содержательные контекст 
 При помощи префиксов add addFirstName addLastName
 Или разделить функцию на меньшие смысловые фрагменты создав класс и сделать переменные полями этого класса // уточнить

14.  Не добавлять избыточный контекст 
 Если приложение называется Gas Station Deluxe, не нужно снабжать имя класса префиксом GSD
Функции
15. Функции Компактность 
 Функции должны быть максимально понятными 

16.  Правило одной операции
 Функция должна выполнять одну операцию. 

17.  Один уровень абстракции
 Все Команды функции должны находиться на одном уровне абстракции. //Уточнить
 1 уровень залез в базу
 2 уровень прочитал данные
 3 отрисовал данные 
 Если добавляется необходимость подключения к базе номер 2 то реализация должна быть выполнена на 1 уровне.

18. Чтение кода сверху вниз: правило понижения
 За каждой функцией должны следовать функции следующего уровня абстракции. // уточнить 

19. Аргумент функции 
 Унарная и бинарная, максимум тернарная. (Не более 3, в идеале без аргументов)полинарных быть Не должно. Сложно тестировать как входные параметры так и проблемы с выходными.

20. Избавиться от побочных эффектов. 
 Функция не должно выполнять скрытых операций (работа должна быть прозрачной для понимания)
21. Разделение команд и запросов.
 Функция должна либо изменять состояние объекта либо возвращать информацию о нем, но не все вместе.

22. Не повторяйтесь (Do not repeat your self)
 Код не должен повторяться, все технологии программирования являются стратегиями борьбы с дублированием 

23. Структурное программирование 
 Изложено Эдгаром Дейкстрой
 Каждая функция должна иметь 1 точку входа и одну выхода. (Return, continue, goto)
 Не должны использоваться никогда. /// в компактной функции все кроме goto можно использовать. 

Комментарии
24. Комментарии не компенсируют плохого кода 
 Если нет понимания кода, лучше его переписать.

25. Юридический комментарий 
 Например заявление об авторских правах, лучше ограничатся ссылкой на лицензию.

26. Информативные комментарии 
 // Поиск по формату: kk:mm:ss EEE. MMM dd, yyyy
 Пример регулярное выражение предназначенное для идентификации времени и даты. (Также можно избежать комментария переместив код в спец. Класс) 

27. Представление намерений 
 // мы пытаемся.. (комментарий о намерении, не лучший способ документирования)  

28. Прояснение 
 Комментарий прояснения уместен если это код вы не можете изменить например библиотека. (Есть риск что комментарий окажется неверным, лучше тщательно смотреть за выходными и входными параметрами и сделать их более понятными)

29. Предупреждение о последствии
 Обьясняет почему конкретный сценарий был отключён, такой комментарий бывает полезным. (Поможет ретивому программисту более серьезно отнестись к данному сценарию) 

30. TODO
 Что по мнению программиста сделать необходимо, но по какой то причине нельзя сделать прямо сейчас. ( Нужно регулярно просматривать и редактировать удалить те, которые потеряли актуальность)

31. Усиление
 Подчёркивает важность обстоятельства, которое на первый взгляд кажется не существенным.
 //вызов trim() важен. Он удаляет начальные проблемы

32. Комментарий JS в общедоступных API
 Если речь идёт о разработке API для общего пользования, для него следует написать хорошие комментарии JSDoc, (соблюдая все правила комментирования)
/** 
* @Param {*} name
*/

33. Виды плохих комментариев 
 Подпорки для некачественного кода и оправдания сомнительных решений.
Вертикальное форматирование
34. Вертикальное форматирование
 Желательно, система или приложение должно состоять из файлов от 200 до 500 строк. 

35. Газетная метафора 
 Начальные блоки исходного файла описывают высокоуровневые концепции и алгоритмы, степень детализации увеличивается при перемещении к концу файла. В самом конце собираются все функции и подробности низшего уровня в исходном файле.

36. Вертикальное разделение концепции
 Каждая группа строк представляющая законченную мысль должна быть отделена пустой строкой.

37. Вертикальное сжатие 
 Строки кода между которыми существует тесная связь не должны быть отделены пустой строкой или комментарием 

38. Вертикальное расстояние
 Концепции тесно связанные друг с другом должны находиться поблизости по вертикали. Вертикальное разделение должно показывать насколько они важны для понимания друг друга. 
 -Объявление переменных 
 Переменные следует объявлять как можно ближе к месту использования. Локальные переменные должны перечисляться в начале каждой функции
 Управляющие перемененные циклов объявляться внутри цикла, в отдельном случае в начале блока или перед циклом в длинной функции.
 Переменны экземпляров должны объявляться в начале класса (в хорошо спроектированном проекте они используются многими если не всеми методами класса) 
 Зависимые функции 
 Если одна вызывает другую то вызывающая функция должна быть над вызываемой.
 Концептуальное родство - если фрагменты требуют что бы их вблизи от других фрагментов, то они обладают концептуальными родством. Чем сильнее родство тем меньше вертикальное расстояние.(функция вызывает функцию, группа функций выполняет антологичным операции) 


39. Вертикальное упорядочивание 
 От высокого уровня к более низкому, вызываемая функция расположена ниже вызывающей. (Как в газетных статьях, важные концепции изложены сначала)
Классы
40. Классы 

41. Строение классов 
 Класс должен начинаться со списка переменных
     1) открытые статические константы 
     2) приватные статические переменные
     3) приватные переменные экземпляров 
     (Открытых переменянных обычно нет)
     
За переменными 
Открытые функции
 (Приватные вспомогательные, вызываемые открытыми, непосредственно за самой открытой) - соответсвует правилу понижения, читается как газетная статья. 

42. Инкапсуляция 
 Если тест из того же пакета должен вызывать функцию или обратиться к переменной, используем защищённый или пакетный уровень доступа. Тем не менее начинать следует с поиска способов сохраняющего приватность, ослабление инкапсуляции всегда должно быть последней мерой. 

43. Классы должны быть компактными 
 Класс как и функция должен быть компактным и иметь разумное количество ответственностей.
 Чем туманнее имя класса, тем больше вероятность что он имеет слишком много ответственностей. 


44. Принцип единой ответсвенности (SRP)
 Принцип единой ответсвенности утверждает что класс или модуль должен иметь одну и только одну причину для изменения. 

45. Связность
 Класс должен иметь небольшое количество переменных экземпляров, каждый метод класса должен оперировать с одной или несколькими из этих переменных. Чем с большим количеством переменных работает метод тем выше связанность этого метода со своим классом. (Связность ?класса должна быть высокой) - метода и переменные класса взаимозависимы и существуют как единое целое. 

46. Поддержание связности приводит к уменьшению классов
 При разбиений большой функции с переменными на мелкие, не стоит передавать переменные а лучше преобразовать эти переменные в переменные экземпляров класса. Таким образом разбиение функции на меньшие фрагменты упрощается. (Если группа функций должна работать с некоторыми переменными, группа  образует класс сама по себе. Если классы утрачивают связность, их нужно разбить) 

47. Структурирование с учетом изменений
 Структура класса должна быть такой что бы класс не приходилось открывать и нарушать принцип единой ответсвенности. (Необходимо создать субклассы.)??

48. Изоляция изменений 
 Создание класса прослойки, что бы при тестировани входные данные не изменялись (если мы не можем гарантировать точность данных которые пришли) 


* From Alex Kashuba (https://github.com/akashuba).
