## Командный код
Чеклист представляет из себя оглавление из книги чистый код. Книга большая и очень полезная, но ее лучше читать по оглавлению.   
Имя большинства глав – тезис. Если для вас он очевиден, и не подразумевает разночтений, и вы с ним согласны – можно не чиать.  
В противном случае читать обязательно. Можно не соглашаться, но делать это надо аргументировано.  "А мне не нравится" – не аргумент. 
Примеры согласия или несогласия с каждым из тезисов надо будет суметь показать в личном или эталонном коде.

### Именование
1. Имена должны передавать намерения программиста: 
Имя не должно требовать дополнительных комментариев;
 -должна отвечать на главные вопросы, почему эта переменная существует и что она делает.
 -должно быть содержательным

2.  Избегать дезинформации
 Ложные ассоциации 
 Избегать скрытые значения отличные от предполагаемого 
 -hp это и разновидность Unix и длина гипотенузы.
 -Длинные похожие имена можно спутать, как пример автодополнение 
 -Не стоит писать acountList если данные не в List
 -Строчная l и 1 0 и o (избегать) 

3.  Осмысленные различия 
 -a1, a2 - не несут информации.
 -Есть класс: Product -> ProductInfo и ProductData 
 Info Data не несут полезной информации.

4. Удобопроизносимые имена
Программирование это социальная деятельность и не хочется выглядишь идиотом. GenerationTimestamp вместо genymdhms 

5. Выбирать имена удобные для поиска 
«e» самая распространённая буква английского алфавита подобное именование может быть использовано только только в локальных переменных в коротких методах. Длинна имени должна соответствовать размеру области видимости 

6. Избегать схем кодирования имён
 Плохо произносится, легко сделать опечатку, дополнительная нагрузка для изучения 

7. Избегать мысленных преобразований 
 Не создавать временных заменителей который должен мысленно преобразован 
 (Нет хуже концепции выбрать с если а уже занято) 

8. Имена классов и методов 
 Имена классов и объектов должны быть существительными и их комбинациями Customer, Account, AddressParser. Не использовать: info data processor manager, имя класса не должно быть глаголом.
 Имя методов: глаголы и глагольные сочетания. postPayment, deletePage, save
 Методы чтения / записи get set и is

9. Избегать остроумия
 У всех разное чувство юмора, возможна неправильная трактовка переменных. 

10. Выбирать одно слово для каждой концепции 
 Не должно существовать в разных классах эквивалентных методов (путаница)

11. Использовать имена из пространства решения
Не стесняться использовать термины из области информатики, паттернов, тех.понятий понятных разработчикам AccountVisitor

12. Использовать имена из пространства задачи 
 Если нет подходящих названий из пространства решений, использовать имена из пространства задачи. Уточнить у специалиста предметной области 

13. Добавлять содержательные контекст 
 При помощи префиксов add addFirstName addLastName
 Или разделить функцию на меньшие смысловые фрагменты создав класс и сделать переменные полями этого класса // уточнить

14.  Не добавлять избыточный контекст 
 Если приложение называется Gas Station Deluxe, не нужно снабжать имя класса префиксом GSD

### Функции
15. Функции Компактность 
 Функции должны быть максимально понятными 

16.  Правило одной операции
 Функция должна выполнять одну операцию. 

17.  Один уровень абстракции
 Все Команды функции должны находиться на одном уровне абстракции. //Уточнить
 1 уровень залез в базу
 2 уровень прочитал данные
 3 отрисовал данные 
 Если добавляется необходимость подключения к базе номер 2 то реализация должна быть выполнена на 1 уровне.

18. Чтение кода сверху вниз: правило понижения
 За каждой функцией должны следовать функции следующего уровня абстракции. // уточнить 

19. Аргумент функции 
 Унарная и бинарная, максимум тернарная. (Не более 3, в идеале без аргументов)полинарных быть Не должно. Сложно тестировать как входные параметры так и проблемы с выходными.

20. Избавиться от побочных эффектов. 
 Функция не должно выполнять скрытых операций (работа должна быть прозрачной для понимания)
21. Разделение команд и запросов.
 Функция должна либо изменять состояние объекта либо возвращать информацию о нем, но не все вместе.

22. Не повторяйтесь (Do not repeat your self)
 Код не должен повторяться, все технологии программирования являются стратегиями борьбы с дублированием 

23. Структурное программирование 
 Изложено Эдгаром Дейкстрой
 Каждая функция должна иметь 1 точку входа и одну выхода. (Return, continue, goto)
 Не должны использоваться никогда. /// в компактной функции все кроме goto можно использовать. 

### Комментарии
24. Комментарии не компенсируют плохого кода 
 Если нет понимания кода, лучше его переписать.

25. Юридический комментарий 
 Например заявление об авторских правах, лучше ограничатся ссылкой на лицензию.

26. Информативные комментарии 
 // Поиск по формату: kk:mm:ss EEE. MMM dd, yyyy
 Пример регулярное выражение предназначенное для идентификации времени и даты. (Также можно избежать комментария переместив код в спец. Класс) 

27. Представление намерений 
 // мы пытаемся.. (комментарий о намерении, не лучший способ документирования)  

28. Прояснение 
 Комментарий прояснения уместен если это код вы не можете изменить например библиотека. (Есть риск что комментарий окажется неверным, лучше тщательно смотреть за выходными и входными параметрами и сделать их более понятными)

29. Предупреждение о последствии
 Обьясняет почему конкретный сценарий был отключён, такой комментарий бывает полезным. (Поможет ретивому программисту более серьезно отнестись к данному сценарию) 

30. TODO
 Что по мнению программиста сделать необходимо, но по какой то причине нельзя сделать прямо сейчас. ( Нужно регулярно просматривать и редактировать удалить те, которые потеряли актуальность)

31. Усиление
 Подчёркивает важность обстоятельства, которое на первый взгляд кажется не существенным.
 //вызов trim() важен. Он удаляет начальные проблемы

32. Комментарий JS в общедоступных API
 Если речь идёт о разработке API для общего пользования, для него следует написать хорошие комментарии JSDoc, (соблюдая все правила комментирования)
/** 
* @Param {*} name
*/

33. Виды плохих комментариев 
 Подпорки для некачественного кода и оправдания сомнительных решений.
Вертикальное форматирование
34. Вертикальное форматирование
 Желательно, система или приложение должно состоять из файлов от 200 до 500 строк. 

35. Газетная метафора 
 Начальные блоки исходного файла описывают высокоуровневые концепции и алгоритмы, степень детализации увеличивается при перемещении к концу файла. В самом конце собираются все функции и подробности низшего уровня в исходном файле.

36. Вертикальное разделение концепции
 Каждая группа строк представляющая законченную мысль должна быть отделена пустой строкой.

37. Вертикальное сжатие 
 Строки кода между которыми существует тесная связь не должны быть отделены пустой строкой или комментарием 

38. Вертикальное расстояние
 Концепции тесно связанные друг с другом должны находиться поблизости по вертикали. Вертикальное разделение должно показывать насколько они важны для понимания друг друга. 
 -Объявление переменных 
 Переменные следует объявлять как можно ближе к месту использования. Локальные переменные должны перечисляться в начале каждой функции
 Управляющие перемененные циклов объявляться внутри цикла, в отдельном случае в начале блока или перед циклом в длинной функции.
 Переменны экземпляров должны объявляться в начале класса (в хорошо спроектированном проекте они используются многими если не всеми методами класса) 
 Зависимые функции 
 Если одна вызывает другую то вызывающая функция должна быть над вызываемой.
 Концептуальное родство - если фрагменты требуют что бы их вблизи от других фрагментов, то они обладают концептуальными родством. Чем сильнее родство тем меньше вертикальное расстояние.(функция вызывает функцию, группа функций выполняет антологичным операции) 

39. Вертикальное упорядочивание 
 От высокого уровня к более низкому, вызываемая функция расположена ниже вызывающей. (Как в газетных статьях, важные концепции изложены сначала)
Классы

### Классы 

40. Строение классов 
 Класс должен начинаться со списка переменных
     1) открытые статические константы 
     2) приватные статические переменные
     3) приватные переменные экземпляров 
     (Открытых переменянных обычно нет)
     
За переменными 
Открытые функции
 (Приватные вспомогательные, вызываемые открытыми, непосредственно за самой открытой) - соответсвует правилу понижения, читается как газетная статья. 

41. Инкапсуляция 
 Если тест из того же пакета должен вызывать функцию или обратиться к переменной, используем защищённый или пакетный уровень доступа. Тем не менее начинать следует с поиска способов сохраняющего приватность, ослабление инкапсуляции всегда должно быть последней мерой. 

42. Классы должны быть компактными 
 Класс как и функция должен быть компактным и иметь разумное количество ответственностей.
 Чем туманнее имя класса, тем больше вероятность что он имеет слишком много ответственностей. 


43. Принцип единой ответсвенности (SRP)
 Принцип единой ответсвенности утверждает что класс или модуль должен иметь одну и только одну причину для изменения. 

44. Связность
 Класс должен иметь небольшое количество переменных экземпляров, каждый метод класса должен оперировать с одной или несколькими из этих переменных. Чем с большим количеством переменных работает метод тем выше связанность этого метода со своим классом. (Связность ?класса должна быть высокой) - метода и переменные класса взаимозависимы и существуют как единое целое. 

45. Поддержание связности приводит к уменьшению классов
 При разбиений большой функции с переменными на мелкие, не стоит передавать переменные а лучше преобразовать эти переменные в переменные экземпляров класса. Таким образом разбиение функции на меньшие фрагменты упрощается. (Если группа функций должна работать с некоторыми переменными, группа  образует класс сама по себе. Если классы утрачивают связность, их нужно разбить) 

46. Структурирование с учетом изменений
 Структура класса должна быть такой что бы класс не приходилось открывать и нарушать принцип единой ответсвенности. (Необходимо создать субклассы.)??

47. Изоляция изменений 
 Создание класса прослойки, что бы при тестировани входные данные не изменялись (если мы не можем гарантировать точность данных которые пришли) 
