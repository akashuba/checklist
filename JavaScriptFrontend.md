## JavaScript Фронтэнд
* способы оптимизации работы с ДОМом. Список самых дорогих операций
* манипуляции с DOM - поиск, добавление, изменение, удаление классов и узлов
* repaint и reflow



### способы оптимизации
1. Работать с «offline» элементом (т.е. который находится не в DOM, а в памяти), с последующим помещением его в DOM.
Добавляем в дом дерево фрагмент из элементов / а не каждый раз обращаемся к дом дереву для добовдления элемента
```
const  fragment = document.createDocumentFragment();
fragment.appendChild(li)
list.appendChild(fragment)
```
2. Для изменения стилей элементов лучше модифицировать только атрибут «class», и как можно глубже в дереве DOM.
3. Анимировать желательно только абсолютно и фиксировано спозиционированные элементы.
4. ...TODO...

### cписок самых дорогих операций
TODO


#### поиск  

| Метод                   | Ищет по..       | Ищет внутри элемента? | Возвращает живую коллекцию?|
|:----------------------- |:---------------:| ---------------------:| --------------------------:|
| querySelector           |CSS-selector     |+                      |-                           |
| querySelectorAll        |CSS-selector     |+                      |_                           |
| getElementById          |id               |-                      |_                           |
| getElementsByName       |name             |_                      |+                           |    
| getElementsByTagName    |tag or '*'       |+                      |+                           |
| getElementsByClassName  |class            |+                      |+                           |


### добавление
Создаёт новый элемент с заданным тегом:
``` 
let div = document.createElement('div’);
```

Создаёт новый текстовый узел с заданным текстом:
```  
let textNode = document.createTextNode('А вот и я’);
```
Клонирует элемент, если deep==true, то со всеми дочерними элементами.
```
elem.cloneNode(deep)
```
методы для различных вариантов вставки:
```  
node.append(...nodes or strings) – добавляет узлы или строки в конец node,
node.prepend(...nodes or strings) – вставляет узлы или строки в начало node,
node.before(...nodes or strings) –- вставляет узлы или строки до node,
node.after(...nodes or strings) –- вставляет узлы или строки после node,
```
 
### изменение
```
node.replaceWith(...nodes or strings) –- заменяет node заданными узлами или строками.
```

### удаление классов
```
elem.classList.add/remove("class") – добавить/удалить класс.
elem.classList.toggle("class") – добавить класс, если его нет, иначе удалить.
elem.classList.contains("class") – проверка наличия класса, возвращает true/false.
```

### удаление узлов  
```
node.remove()
```
### The rendering process of a web page
![rebase](/img/browser_flow.png)

### repaint  
В случае изменения стилей элемента, не влияющих на его размеры и положение на странице (например, background-color, border-color, visibility), браузер просто отрисовывает его заново, с учётом нового стиля — происходит repaint (или restyle).

### reflow  
Если же изменения затрагивают содержимое, структуру документа, положение элементов — происходит  
reflow (или relayout).  
Причинами таких изменений обычно являются:  
* Манипуляции с DOM (добавление, удаление, изменение, перестановка элементов);
* Изменение содержимого, в т.ч. текста в полях форм;
* Расчёт или изменение CSS-свойств;
* Добавление, удаление таблиц стилей;
* Манипуляции с атрибутом «class»;
* Манипуляции с окном браузера — изменения размеров, прокрутка;
*  Активация псевдо-классов (например, :hover).

Браузеры по возможности локализуют repaint и reflow в пределах элементов, подвергнувшимися изменению.    
Например, изменение размеров абсолютно или фиксировано спозиционированного элемента затронет только  
сам элемент и его потомков, в то время как изменение статично спозиционированного — повлечет reflow всех элементов, следующих за ним.

#### Аппаратное ускорение
Использование GPU для отрисовки слоев графики. В CSS могут быть обработаны напрямую через GPU:
* transform
* opacity
* fulter
* 3D трансформации ( translate Z )
* тэги Video Canvas
* z-index
В этом случае создается отдельный слой обрабатываемый через GPU.

### cписок самых дорогих операций.
TODO

