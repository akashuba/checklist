# Console
* создать файл и директорию, удалить, скопировать, переместить;
* chmod
* chown
* ssh, scp
* find/grep
* vim: создать файл, сохранить, отредактировать, выйти (с сохранением и без)
* top/kill

***
 
### создать файл
* Используя утилиту touch
```
touch file.txt
```

Используя редактор
```
vim file.txt
nano file.txt
cat file.txt
```

Оператор перенаправления
```
> file.txt
echo «строка» > file.txt
```

### создать директорию 
Cоздание каталогов выполняется командой "mkdir" (от англ. make directory):
```
mkdir dir_name
```

Создать директорию с именем "dir1»:
```
mkdir dir1
```

Создать две директории одновременно:
```
mkdir dir1 dir2
```

Создать дерево директорий:
```
mkdir -p /dir1/dir2
```

### Удалить файл
Для удаления файлов используется команда "rm" (от англ. remove).
Работает очень просто, пишете команду rm и путь к файлу, который хотите удалить:
Удалить файл с именем "file1»:
```
rm file1
```

Но команда "rm" позволяет удалять не только файлы, но и директории (каталоги) вместе с их содержимым
Удалить директорию с именем "dir1" и рекурсивно всё её содержимое:
```
rm -r dir1
```

Удалить две директории и рекурсивно их содержимое:
```
rm -r dir1 dir2
```

Также можно добавить параметр -f, который означает, что при удалении не будет запрашиваться подтверждение на удаление. Команды будут выглядеть так:
```
rm -f file1
rm -rf dir1
```

### Cкопировать файл
$cp опции файл-источник файл-приемник
$ cp опции файл-источник директория-приемник/

Список опций: 
* --attributes-only - не копировать содержимое файла, а только флаги доступа и владельца;
* -f, --force - перезаписывать существующие файлы;
* -i, --interactive - спрашивать, нужно ли перезаписывать существующие файлы;
* -L - копировать не символические ссылки, а то, на что они указывают;
* -n - не перезаписывать существующие файлы;
* -P - не следовать символическим ссылкам;
* -r - копировать папку Linux рекурсивно;
* -s - не выполнять копирование файлов в Linux, а создавать символические ссылки;
* -u - скопировать файл, только если он был изменён;
* -x - не выходить за пределы этой файловой системы;
* -p - сохранять владельца, временные метки и флаги доступа при копировании;
* -t - считать файл-приемник директорией и копировать файл-источник в эту директорию.
Пример:  
```
cp ~/pic.png ~/pictures/
```

### Переместить 
Чтобы переместить файл в другое место или изменить его имя, используйте команду mv (``move''). Она принимает два аргумента: имя файла или каталога для перемещения, а затем имя пути для перемещения. Если Вы перемещаете файл в каталог, в котором уже есть файл с таким именем, то он будет перезаписан.
Чтобы переместить файл notes из текущего рабочего каталога в каталог ../play
```
$ mv notes ../play
```


Если в родительском каталоге текущего каталога нет подкаталога play, эта команда переместит файл notes в родительский каталог и переименует его в play.
Чтобы переместить файл или каталог, который не находится в текущем каталоге, укажите в качестве аргумента его полное имя и путь.
Чтобы переместить файл `/usr/tmp/notes' в текущий рабочий каталог.
```
$ mv /usr/tmp/notes
```


Чтобы переместить каталог, укажите путь к каталогу, который нужно переместить и путь к каталогу-приемнику.
Чтобы переместить каталог work из текущего рабочего каталога в каталог play.
```
$ mv work play
```


Если каталог play уже существует, mv поместит work внутрь play - эта команда не перезаписывает каталоги.
Переименование файла - это то же самое, что и его перемещение; просто укажите в качестве аргументов файл для переименования и его новое имя.
Чтобы переименовать файл notes в notes.old
```
$ mv notes notes.old
```

### chmod
$ chmod опции права /путь/к/файлу
* 0 - никаких прав;
* 1 - только выполнение;
* 2 - только запись;
* 3 - выполнение и запись;
* 4 -  только чтение;
* 5 - чтение и выполнение;
* 6 - чтение и запись;
* 7 - чтение запись и выполнение.

Права на папку linux такие же, как и для файла. Во время установки прав сначала укажите цифру прав для владельца, затем для группы, а потом для остальных. 
* 744 - разрешить все для владельца, а остальным только чтение;
* 755 - все для владельца, остальным только чтение и выполнение;
* 764 - все для владельца, чтение и запись для группы, и только чтение для остальных;
* 777 - всем разрешено все. 
 
Пример 
```
chmod 766 file
```

### chown
Команда chown позволяет менять только владельца и группу
$ chown пользователь опции /путь/к/файлу

```
chown root ./dir1 
```
изменим владельца папки dir1 на root:

```
chown root:root ./dir2 
```
поменять сразу владельца и группу каталога

```
chown -R root:root ./dir3
```
применить изменения ко всем подкаталогам -R

### ssh
Сетевой протокол. Используется для удаленного управления операционными системами и передачи файлов.  
Ключевая особенность заключается в том, что SSH шифрует трафик, делая подключения безопасными. 
По умолчанию, использует 22-й порт. Аббревиатура расшифровывается как Secure Shell.  
Программные реализации SSH делятся на серверные и клиентские части.   
В основном, в качестве сервера применяется OpenSSH, клиентов — OpenSSH (UNIX), PuTTYили SecureCRT (Windows, Linux)  
Пример подключения по SSH из командной строки Linux:  
```
ssh root@192.168.0.15
```

* root — учетная запись, из-под которой выполняем подключение;
* 192.168.0.15 — IP-адрес компьютера, с которым соединяемся. 

Для получения полного списка ключей можно воспользоваться командой 
```
man ssh.

```

### scp 
SCP (от англ. secure copy) — утилита и протокол копирования , в отличие от утилиты RCP, в качестве транспорта не RSH, а шифрованный SSH. Сходная по функционалу утилита — sftp.
В UNIX-подобных операционных системаходноимённая (scp) утилита удалённого копирования файлов часто входит в состав пакета openssh.  
Команда копирования локального SourceFile на удалённый хост:  
```
scp SourceFile user@host:/directory/TargetFile
```

Команда копирования SourceFile с удалённого хоста:
```
scp user@host:/directory/SourceFile TargetFile
```

Если ssh работает на другом порту, то тогда указывается:
```
scp -P port user@host:/directory/SourceFile /directory/TargetFile
```

Копирование SourceFolder с удалённого хоста внутрь локального TargetFolder (на локальном хосте получится, что SourceFolder будет находиться внутри TargetFolder):
```
scp -r user@host:/directory/SourceFolder TargetFolder
```

### find 
Find - это одна из наиболее важных и часто используемых утилит системы Linux.  
Это команда для поиска файлов и каталогов на основе специальных условий.  
Ее можно использовать в различных обстоятельствах, например, для поиска файлов по разрешениям, владельцам, группам, типу, размеру и другим подобным критериям.  
find [папка] [параметры] критерий шаблон [действие]
* Папка - каталог в котором будем искать
* Параметры - дополнительные параметры, например, глубина поиска, и т д
* Критерий - по какому критерию будем искать: имя, дата создания, права, владелец и т д.
* Шаблон - непосредственно значение по которому будем отбирать файлы.  

Основные параметры:
-P никогда не открывать символические ссылки  
-L - получает информацию о файлах по символическим ссылкам. Важно для дальнейшей обработки, чтобы обрабатывалась не ссылка, а сам файл.  
-maxdepth - максимальная глубина поиска по подкаталогам, для поиска только в текущем каталоге установите 1.  
-depth - искать сначала в текущем каталоге, а потом в подкаталогах  
-mount искать файлы только в этой файловой системе.  
-version - показать версию утилиты find  
-print - выводить полные имена файлов  
-type f - искать только файлы  
-type d - поиск папки в Linux    

Основные критерии   
-name - поиск файлов по имени  
-perm - поиск файлов в Linux по режиму доступа  
-user - поиск файлов по владельцу  
-group - поиск по группе  
-mtime - поиск по времени модификации файла  
-atime - поиск файлов по дате последнего чтения  
-nogroup - поиск файлов, не принадлежащих ни одной группе  
-nouser - поиск файлов без владельцев  
-newer - найти файлы новее чем указанный  
-size - поиск файлов в Linux по их размеру  
[Примеры:](https://losst.ru/komanda-find-v-linux)

### grep (Global regular expression printer) 
Утилита командной строки, которая находит на вводе целые строки, отвечающие заданному регулярному выражению, и выводит их, если вывод не отменён специальным ключом.  
Примеры grep в чистом виде.

```
$ grep '12:00' /home/david/backup/log.txt
```
производит поиск подстроки 12.00 в файле /home/david/backup/log.txt и отображает все строки где эта подстрока встречается.
Эта комбинация может быть использована например для поиска бекапов которые происходили в 12:00.


```
$ grep -v '12.00' /home/david/backup/log.txt
```
с использованием ключа -v наоборот покажет только те строки где подстрока ’12:00′ не встречается.


```
$ grep -l 'delay' /code/*.c
```
Ищет все файлы оканчивающиеся на .c и текст в найденых файлах соответствующий подстроке 'delay' и в конечном итоге выведет только имена файлов где эта подстрока встречается.


```
$ grep -w '\<bay' * $ grep -w 'watch\>' 
```
состоит из комбинации двух команд grep. Первая ищет строки которые начинаются со слова ‘bay’ а вторая строки которые заканчиваются на слово ‘watch’.
Примеры grep использования вместе с потоком. 


```
$ ls -l | grep rwxrwxrwx
```
Часть grep rwxrwxrwx фильтрует результат полученый от ls -l и выводит только те директории у которых установлены соответствующие права доступа.  
Вывод от команды grep может также быть направлен потоком в другую команду, например как в следующем примере:  


```
$ du | grep 'mp3' | more
```
выводит постранично список mp3 файлов найденых в текущей директории.


```
$ grep '^#' /home/david/script1 | more
```
отобразит все строки в файле /home/david/script1 которые начинаются с символа ‘#’. Определение тип ‘^#’ означает что символ ‘#’ должен быть первым символом с троке.


```
$ grep -v '^[0-9]' /home/david/backup/log.txt | more
```
ищет строки содержащие в первом символе цифры от 0 до 9 а потом выводит только те строки которые не попали в результаты поиска. Как вы видите — был использован ключ ‘-v’ означающий реверсивный поиск.  
Важно: Необходимо заключать искомые строки в одинарные кавычки как указано в двух предыдущих примерах для того чтобы интерпретатор командной строки мог воспринимать их корректно. Иначе интерпретатор  может понять это как другую команду и результат выполнения будет непредсказуем.
    
### vim: создать файл, сохранить, отредактировать, выйти (с сохранением и без)  
        
VIM - это свободный текстовый редактор, возможности которого во многом превосходят возможности обычного редактора.  
Однако есть минус - интерфейс редактора не интуитивен, поэтому для работы с ним нужно некоторое время потратить на изучение команд, горячих клавиш и т.п.   
VIM имеет три режима работы: 

* командный 
* режим редактирования 
* визуальный режим

Для перехода в командный режим требуется нажатие Esc.    
Все команды в VIM вводятся с символа двоеточия - ":" (без кавычек).  
Для перехода в визуальный режим требуется нажатие Ctrl+V.   
q - закрыть файл, если не требует сохранения, т.е. в файле не было изменений. В противном случае VIM выдаст сообщение об ошибке, как показано на рисунке;   

:q! - закрыть файл без сохранения;  
:qa! - закрыть все файлы без сохранения;  
:wq - закрыть и сохранить файл;  
:wqa - закрыть все файлы с сохранением.  

Работа с текстом 
1. Перемещение по тексту.
VIM обладает большими возможностями для ускорения работы с текстом и имеет большое количество команд для перемещения по тексту.
Для перемещения можно использовать стрелочки, а также h (Влево), l (Вправо), j (Вниз), k (Вверх). 
Другие команды для перемещения по тексту: 
|, 0, home — в начало строки;
^ — на первый непустой символ в строке;
$, end — в конец строки;
m — на половину ширины экрана;
g — на нижнюю строку;
e — до конца слова;
- — на строку вверх и на первый непустой символ;
+, Enter — на строку вниз и на первый непустой символ;
G — на последнюю строку;
H — на первую строку экрана;
M — на среднюю строку экрана;
L — на последнюю строку экрана;
w — на слово вперед;
b — на слово назад;
( — на предложение назад (до точки);
) — на предложение вперед (до точки);
{ — на абзац назад (до пустой строки);
} — на абзац вперед (до пустой строки);
:ju — список переходов.

2. Редактирование текста. 
VIM также имеет большое количество возможностей для быстрого редактирования. 
Del, x - удаление символа под курсором;
X - удаление символа перед курсором;
u, :u — отмена последнего действия;
U — отменить все изменения, повлиявшие на текущую строку;
~ — перевести в верхний или нижний регистр в зависимости от текущего символа под курсором;
C — удалить от курсора и до конца строки с переходом в режим ввода;
D — удалить от текущего символа до конца строки;
dd — вырезать строку, на которой стоит курсор. Перед любой командой можно ввести числовой модификатор, который укажет сколько раз выполнить команду. Например: 3dd - удалит три строки начиная с текущей;
yy — копирует строку. Также можно использовать числовой модификатор;
p — вставить после текущей строки;
P — вставить перед текущей строкой;
<< — сдвиг влево текущей строки;
>> — сдвиг вправо текущей строки;
J — объединение текущей строки с последующей.

3. Для программистов 
:set number — включить отображение номеров строк;
:set nonumber — отключить отображение номеров строк;
= — расстановка отступов для языка программирования С. 

### top/kill
top (table of processes) — консольнаякоманда, которая выводит список работающих в системе процессов и информацию о них.  
По умолчанию она в реальном времени сортирует их по нагрузке на процессор.

1 строка общая реформация top, выводит данные по порядку:
* текущее время
* время работы системы
* количество открытых пользовательских сессий
* среднюю загрузку системы

2 строка - статистика процессов во второй строке следующие данные:
* общее количество процессов в системе
* количество работающих в данный момент процессов
* количество ожидающих событий процессов
* количество остановленных процессов
* количество процессов, ожидающих родительский процесс для передачи статуса завершения

3 строка - статистика использования центрального процессора, в третьей строке приводится информация об использовании центрального процессора.  
Если вы просуммируете все значения, в результате у вас должно получиться 100%. Давайте рассмотрим предназначение полей этой строки по порядку:
* процент использования центрального процессора пользовательскими процессам
* процент использования центрального процессора системными процессами
* процент использования центрального процессора процессами с приоритетом, повышенным при помощи вызова nice
* процент времени, когда центральный процессор не используется
* процент использования центрального процессора процессами, ожидающими завершения операций ввода-вывода
* процент использования центрального процессора обработчиками аппаратных прерываний
* процент использования центрального процессора обработчиками программных прерываний
* количество ресурсов центрального процессора "заимствованных" у виртуальной машины гипервизором для других задач (таких, как запуск другой виртуальной машины); это значение будет равно нулю на настольных компьютерах и серверах, не использующих виртуальные машины

4 и 5 строки - статистика использования памяти (memory usage), выводится информация об использовании физической оперативной памяти и раздела подкачки соответственно. Значения в порядке следования: общее количество памяти (2057720k total), количество используемой памяти (778860k used), количество свободной памяти (1279160k free), количество памяти в кэше буферов (31976k buffers).

Последним источником информации является список процессов, отсортированный по степени использования центрального процессора (по умолчанию).  
Значения столбцов списка:
* PID - идентификатор процесса
* USER - имя пользователя, который является владельцем процесса (root)
* PR - приоритет процесса
* NI - значение "NICE", влияющие на приоритет процесса
* VIRT - объем виртуальной памяти, используемый процессом
* RES - объем физической памяти, используемый процессом
* SHR - объем разделяемой памяти процесса
* S - указывает на статус процесса: S=sleep (ожидает событий) R=running (работает) Z=zombie (ожидает родительский процесс) (S)
* %CPU - процент использования центрального процессора данным процессом
* %MEM - процент использования оперативной памяти данным процессом
* TIME+ - общее время активности процесса
* COMMAND - имя процесса

```
kill
``` 
Когда вы выполняете команду "kill", то фактически вы посылаете системе сигнал, чтобы заставить ее завершить некорректно ведущее себя приложение. Всего вы можете использовать до 60 сигналов
Основные два сигнала это 
SIGTERM (15) и SIGKILL (9)

```
kill -l
``` (посмотреть перечень всех сигналов)

SIGTERM - этот сигнал запрашивает остановку работы процесса. Он может быть проигнорирован. Процессу дается время на корректное завершение. Если программа завершается корректно, значит она использовала данное время на то, чтобы сохранить свое состояние или результаты работы и освободить ресурсы. Другими словами, ее не заставляли остановиться.
SIGKILL - этот сигнал заставляет процесс прекратить работу немедленно. Программа не может проигнорировать этот сигнал. Несохраненные результаты будут потеряны.
kill [сигнал или опция] PID
Сигнал по умолчанию (если он не задан) - SIGTERM. Если он не помогает, для принудительного завершения процесса можно использовать следующие варианты:
```
kill SIGKILL PID
kill -9 PID
```
где флаг "-9" ссылается на сигнал SIGKILL.

Если вы не знаете точно PID приложения, просто запустите команду:
```
ps ux
```
Она выведет информацию по всем запущенным программам.
Также обратите внимание, что можно завершать несколько процессов одной командой.
```
kill -9 PID1 PID2 PID 3
```
Команда "pkill" позволяет использовать расширенные шаблоны регулярных выражений и другие критерии соответствия. Вместо использования PID вы теперь можете завершить приложение, введя имя его процесса. Например, для завершения работы Firefox просто введите команду:
```
pkill firefox
```
Так как оно соответствует шаблону регулярного выражения, вы можете также ввести имя только частично, например:
```
pkill fire
```
Чтобы предотвратить завершение не тех приложений, которые требовалось, можно использовать команду "pgrep -l [process name]" для вывода списка всех подходящих процессов.
```
Killall 
```
также использует имя процесса вместо PID и завершает все экземпляры процесса с этим именем. Например, если вы запустили несколько экземпляров Firefox, вы можете завершить их все с помощью команды:

```
killall firefox
```
В Gnome вы можете перезапустить Nautilus с помощью команды:
```
killall nautilus
```
Xkill - это графический способ завершения приложений. Когда вы введете "xkill" в терминале, курсор примет вид крестика. Все, что вам требуется, кликнуть этим крестиком в окне нужного приложения и оно немедленно завершится. Если вам понравится такой способ, можно настроить для активации xkill горячие клавиши.

